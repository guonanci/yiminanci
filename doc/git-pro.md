#1起步 及 历史

1.1.2 集中化的版本控制系统
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版
本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系
图 1.1: 本地版本控制系统
统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存
所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或
者提交更新。多年以来，这已成为版本控制系统的标准做法（见图 1-2）。

这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在
一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权
限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。
事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小
时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发
生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢
失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就
成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完
整提取出来过。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一
位置，就有丢失所有历史更新记录的风险。

1.1.3 分布式版本控制系统
于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世
了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版
本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器
发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际
上都是一次对代码仓库的完整备份（见图 1-3）。
图 1.3: 分布式版本控制系统
更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可
以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流
程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。



文件快照是什么意思...

##1.2 git 简史
同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开
源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存
归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控
制系统 BitKeeper 来管理和维护代码。
到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他
们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者
Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈
覆辙。他们对新的系统制订了若干目标：

速度

简单的设计

对非线性开发模式的强力支持（允许上千个并行开发的分支）

完全分布式

有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）
自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的
目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统
（见第三章），可以应付各种复杂的项目开发需求。

##1.3 git 基础
Subversion Perforce
如果理解了 git 的思想和基本工作原理, 就会用起来游刃有余.开始学习 git 的时候, 不要尝试把各种概念


和其他版本控制系统（诸如 Subversion 和 Perforce 等）相
比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起
来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于
你准确地使用 Git 提供的各种工具。
1.3.1 直接记录快照，而非差异比较
Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大
多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，
Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图


git会把出现变更的文件直接拷贝，形成新的blob，而非与上一个版本的diff。所以一旦需要查看某版本直接load即可，而其他差异版本控制需要做merge，所以快。空间换时间。并非每个当前版本都需要做备份，如果没有改变，那么快照其实是链接上一个版本。git会在隐藏目录.git里存在object里，定期会优化，保证快照空间，和读取时间的平衡。

作者：知乎用户
链接：https://www.zhihu.com/question/27680108/answer/62905277
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记
录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件
作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再
次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。
图 1.5: Git 保存每次更新时的文件快照
这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实
现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的
4
Scott Chacon Pro Git 1.3节 Git 基础
超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再
看看这样的设计究竟会带来哪些好处

###1.3.2 近乎所有操作都是本地执行
在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。(git log 一下, 自项目创建以来, 所有的 log 都会列出来, 而不需要依靠网络, 然后 reset 过去)但如果用 CVCS 的
话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史
更新，所以处理起来速度飞快。
举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回
来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。
如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和
当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本
地来作比较

1.3.3 时刻保持数据完整性
在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作
为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。
这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完
整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。
Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个
SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起
来就像是：
24b9da6552252987aa493b52f8696cd6d3b00373
Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保
存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。


好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种
状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该
文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保
存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。
由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，
以及本地仓库。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件
实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这
些文件进行编辑。
所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文
件叫做索引文件，不过标准说法还是叫暂存区域。
基本的 Git 工作流程如下：
1. 在工作目录中修改某些文件。
2. 对修改后的文件进行快照，然后保存到暂存区域。
3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。
所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文
件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次
6
Scott Chacon Pro Git 1.4节 安装 Git
取出后，作了修改但还没有放到暂存区域，就是已修改状态。到第二章的时候，我们会进一
步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交

#2git 基础
###2.1.2 从现有仓库克隆
如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要
用到 git clone 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使
用的是 clone 而不是 checkout。这是个非常重要的差别，Git 收取的是项目历史的所有数据
（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服
务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初
克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有
关细节请参考第四章）。
克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可
以用下面的命令：
$ git clone git://github.com/schacon/grit.git
这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下
来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你
会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时
候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字

$ git clone git://github.com/schacon/grit.git mygrit
唯一的差别就是，现在新建的目录成了 mygrit，其他的都和上边的一样。
Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s)://
或者 user@server:/path.git 表示的 SSH 传输协议。我们会在第四章详细介绍所有这些协议在
服务器端该如何配置使用，以及各种方式之间的利弊。

请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件
是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它
们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它
们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的
所有文件都属于已跟踪文件，且状态为未修改。
在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到
暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文
件状态变化周期如图 2-1 所示。
2.2.1 检查当前文件状态
要确定哪些文件当前处于什么状态，可以用 git status 命令。如果在克隆仓库之后立即执
行此命令，会看到类似这样的输出：



$ git status
# On branch master
nothing to commit (working directory clean)
这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改
过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会
在这里列出来。最后，该命令还显示了当前所在的分支是 master，这是默认的分支名称，实
际是可以修改的，现在先不用考虑。

下一章我们就会详细讨论分支和引用。

只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提
交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 git init
后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的
文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实
git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同
时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）

###2.2.3 暂存已修改文件
现在我们修改下之前已跟踪过的文件 benchmarks.rb，然后再次运行 status 命令，会看到
这样的状态报告：
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
# new file: README
#
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
#
# modified: benchmarks.rb
#
文件 benchmarks.rb 出现在 “Changes not staged for commit” 这行下面，说明已跟
踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令
（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪
新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状
###2.2.4忽略某些文件
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通
常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创
建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：

$ cat .gitignore
* .[oa]
// 上面的空格是我加上去的, 否则 .md 会解析 * 连起来的东西为特殊颜色
* ~

第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编
译过程中出现的，我们用不着跟踪它们的的版本。第二行告诉 Git 忽略所有以波浪符（~）
结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可
能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好
.gitignore 文件的习惯，以免将来误提交这类无用的文件

文件 .gitignore 的格式规范如下：

所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。

可以使用标准的 glob 模式匹配。

匹配模式最后跟反斜杠（/）说明要忽略的是目录。

要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（ * ）匹配零个或多个任
意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个
b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两
个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹匹配所有 0 到 9 的数
字）。
我们再看一个 .gitignore 文件的例子：
# 此为注释
将被 Git 忽略
*.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/ # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt


此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有
暂存起来的变化内容。
19
第2章 Git 基础 Scott Chacon Pro Git
若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --cached 命
令。

（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）


记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以
在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回
到这个状态，或者进行比较。

###2.2.7 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提
供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就
会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：(但是新文件就不行这么做...)


最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存
区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢
失修改的内容。
另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望
保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一
堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件
中补上，用 --cached 选项即可：
$ git rm --cached readme.txt

后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：
$ git rm log/\*.log
注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不
用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，
仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等
同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目
录下扩展名为 .log 的文件。类似的比如：
$ git rm \*~
会递归删除当前目录及其子目录中所有 ~ 结尾的文件。
