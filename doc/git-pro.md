#1起步 及 历史

1.1.2 集中化的版本控制系统
接下来人们又遇到一个问题，如何让在不同系统上的开发者协同工作？于是，集中化的版
本控制系统（ Centralized Version Control Systems，简称 CVCS ）应运而生。这类系
图 1.1: 本地版本控制系统
统，诸如 CVS，Subversion 以及 Perforce 等，都有一个单一的集中管理的服务器，保存
所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或
者提交更新。多年以来，这已成为版本控制系统的标准做法（见图 1-2）。

这种做法带来了许多好处，特别是相较于老式的本地 VCS 来说。现在，每个人都可以在
一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权
限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。
事分两面，有好有坏。这么做最显而易见的缺点是中央服务器的单点故障。如果宕机一小
时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。要是中央服务器的磁盘发
生故障，碰巧没做备份，或者备份不够及时，就会有丢失数据的风险。最坏的情况是彻底丢
失整个项目的所有历史更改记录，而被客户端偶然提取出来的保存在本地的某些快照数据就
成了恢复数据的希望。但这样的话依然是个问题，你不能保证所有的数据都已经有人事先完
整提取出来过。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一
位置，就有丢失所有历史更新记录的风险。

1.1.3 分布式版本控制系统
于是分布式版本控制系统（ Distributed Version Control System，简称 DVCS ）面世
了。在这类系统中，像 Git，Mercurial，Bazaar 以及 Darcs 等，客户端并不只提取最新版
本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器
发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的提取操作，实际
上都是一次对代码仓库的完整备份（见图 1-3）。
图 1.3: 分布式版本控制系统
更进一步，许多这类系统都可以指定和若干不同的远端代码仓库进行交互。籍此，你就可
以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流
程，比如层次模型式的工作流，而这在以前的集中式系统中是无法实现的。



文件快照是什么意思...

##1.2 git 简史
同生活中的许多伟大事件一样，Git 诞生于一个极富纷争大举创新的年代。Linux 内核开
源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存
归档的繁琐事务上（1991－2002年间）。到 2002 年，整个项目组开始启用分布式版本控
制系统 BitKeeper 来管理和维护代码。
到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他
们收回了免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区（特别是 Linux 的缔造者
Linus Torvalds ）不得不吸取教训，只有开发一套属于自己的版本控制系统才不至于重蹈
覆辙。他们对新的系统制订了若干目标：

速度

简单的设计

对非线性开发模式的强力支持（允许上千个并行开发的分支）

完全分布式

有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量）
自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的
目标。它的速度飞快，极其适合管理大项目，它还有着令人难以置信的非线性分支管理系统
（见第三章），可以应付各种复杂的项目开发需求。

##1.3 git 基础
Subversion Perforce
如果理解了 git 的思想和基本工作原理, 就会用起来游刃有余.开始学习 git 的时候, 不要尝试把各种概念


和其他版本控制系统（诸如 Subversion 和 Perforce 等）相
比拟，否则容易混淆每个操作的实际意义。Git 在保存和处理各种信息的时候，虽然操作起
来的命令形式非常相近，但它与其他版本控制系统的做法颇为不同。理解这些差异将有助于
你准确地使用 Git 提供的各种工具。
1.3.1 直接记录快照，而非差异比较
Git 和其他版本控制系统的主要差别在于，Git 只关心文件数据的整体是否发生变化，而大
多数其他系统则只关心文件内容的具体差异。这类系统（CVS，Subversion，Perforce，
Bazaar 等等）每次记录有哪些文件作了更新，以及都更新了哪些行的什么内容，请看图


git会把出现变更的文件直接拷贝，形成新的blob，而非与上一个版本的diff。所以一旦需要查看某版本直接load即可，而其他差异版本控制需要做merge，所以快。空间换时间。并非每个当前版本都需要做备份，如果没有改变，那么快照其实是链接上一个版本。git会在隐藏目录.git里存在object里，定期会优化，保证快照空间，和读取时间的平衡。

作者：知乎用户
链接：https://www.zhihu.com/question/27680108/answer/62905277
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



Git 并不保存这些前后变化的差异数据。实际上，Git 更像是把变化的文件作快照后，记
录在一个微型的文件系统中。每次提交更新时，它会纵览一遍所有文件的指纹信息并对文件
作一快照，然后保存一个指向这次快照的索引。为提高性能，若文件没有变化，Git 不会再
次保存，而只对上次保存的快照作一链接。Git 的工作方式就像图 1-5 所示。
图 1.5: Git 保存每次更新时的文件快照
这是 Git 同其他系统的重要区别。它完全颠覆了传统版本控制的套路，并对各个环节的实
现方式作了新的设计。Git 更像是个小型的文件系统，但它同时还提供了许多以此为基础的
4
Scott Chacon Pro Git 1.3节 Git 基础
超强工具，而不只是一个简单的 VCS。稍后在第三章讨论 Git 分支管理的时候，我们会再
看看这样的设计究竟会带来哪些好处

###1.3.2 近乎所有操作都是本地执行
在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网。(git log 一下, 自项目创建以来, 所有的 log 都会列出来, 而不需要依靠网络, 然后 reset 过去)但如果用 CVCS 的
话，差不多所有操作都需要连接网络。因为 Git 在本地磁盘上就保存着所有当前项目的历史
更新，所以处理起来速度飞快。
举个例子，如果要浏览项目的历史更新摘要，Git 不用跑到外面的服务器上去取数据回
来，而直接从本地数据库读取后展示给你看。所以任何时候你都可以马上翻阅，无需等待。
如果想要看当前版本的文件和一个月前的版本之间有何差异，Git 会取出一个月前的快照和
当前文件作一次差异运算，而不用请求远程服务器来做这件事，或是把老版本的文件拉到本
地来作比较

1.3.3 时刻保持数据完整性
在保存到 Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作
为数据的唯一标识和索引。换句话说，不可能在你修改了文件或目录之后，Git 一无所知。
这项特性作为 Git 的设计哲学，建在整体架构的最底层。所以如果文件在传输时变得不完
整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。
Git 使用 SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个
SHA-1 哈希值，作为指纹字符串。该字串由 40 个十六进制字符（0-9 及 a-f）组成，看起
来就像是：
24b9da6552252987aa493b52f8696cd6d3b00373
Git 的工作完全依赖于这类指纹字串，所以你会经常看到这样的哈希值。实际上，所有保
存在 Git 数据库中的东西都是用此哈希值来作索引的，而不是靠文件名。


好，现在请注意，接下来要讲的概念非常重要。对于任何一个文件，在 Git 内都只有三种
状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该
文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保
存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。
由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，
以及本地仓库。

从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件
实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这
些文件进行编辑。
所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文
件叫做索引文件，不过标准说法还是叫暂存区域。
基本的 Git 工作流程如下：
1. 在工作目录中修改某些文件。
2. 对修改后的文件进行快照，然后保存到暂存区域。
3. 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。
所以，我们可以从文件所处的位置来判断状态：如果是 Git 目录中保存着的特定版本文
件，就属于已提交状态；如果作了修改并已放入暂存区域，就属于已暂存状态；如果自上次
6
Scott Chacon Pro Git 1.4节 安装 Git
取出后，作了修改但还没有放到暂存区域，就是已修改状态。到第二章的时候，我们会进一
步了解其中细节，并学会如何根据文件状态实施后续操作，以及怎样跳过暂存直接提交

#2git 基础
###2.1.2 从现有仓库克隆
如果想对某个开源项目出一份力，可以先把该项目的 Git 仓库复制一份出来，这就需要
用到 git clone 命令。如果你熟悉其他的 VCS 比如 Subversion，你可能已经注意到这里使
用的是 clone 而不是 checkout。这是个非常重要的差别，Git 收取的是项目历史的所有数据
（每一个文件的每一个版本），服务器上有的数据克隆之后本地也都有了。实际上，即便服
务器的磁盘发生故障，用任何一个克隆出来的客户端都可以重建服务器上的仓库，回到当初
克隆时的状态（虽然可能会丢失某些服务器端的挂钩设置，但所有版本的数据仍旧还在，有
关细节请参考第四章）。
克隆仓库的命令格式为 git clone [url]。比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可
以用下面的命令：
$ git clone git://github.com/schacon/grit.git
这会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下
来的所有版本记录，然后从中取出最新版本的文件拷贝。如果进入这个新建的 grit 目录，你
会看到项目中的所有文件已经在里边了，准备好后续的开发和使用。如果希望在克隆的时
候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字

$ git clone git://github.com/schacon/grit.git mygrit
唯一的差别就是，现在新建的目录成了 mygrit，其他的都和上边的一样。
Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s)://
或者 user@server:/path.git 表示的 SSH 传输协议。我们会在第四章详细介绍所有这些协议在
服务器端该如何配置使用，以及各种方式之间的利弊。

请记住，工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件
是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它
们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它
们既没有上次更新时的快照，也不在当前的暂存区域。初次克隆某个仓库时，工作目录中的
所有文件都属于已跟踪文件，且状态为未修改。
在编辑过某些文件之后，Git 将这些文件标为已修改。我们逐步把这些修改过的文件放到
暂存区域，直到最后一次性提交所有这些暂存起来的文件，如此重复。所以使用 Git 时的文
件状态变化周期如图 2-1 所示。
2.2.1 检查当前文件状态
要确定哪些文件当前处于什么状态，可以用 git status 命令。如果在克隆仓库之后立即执
行此命令，会看到类似这样的输出：



$ git status
# On branch master
nothing to commit (working directory clean)
这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改
过。此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪的新文件，否则 Git 会
在这里列出来。最后，该命令还显示了当前所在的分支是 master，这是默认的分支名称，实
际是可以修改的，现在先不用考虑。

下一章我们就会详细讨论分支和引用。

只要在 “Changes to be committed” 这行下面的，就说明是已暂存状态。如果此时提
交，那么该文件此时此刻的版本将被留存在历史记录中。你可能会想起之前我们使用 git init
后就运行了 git add 命令，开始跟踪当前目录下的文件。在 git add 后面可以指明要跟踪的
文件或目录路径。如果是目录的话，就说明要递归跟踪该目录下的所有文件。（译注：其实
git add 的潜台词就是把目标文件快照放入暂存区域，也就是 add file into staged area，同
时未曾跟踪过的文件标记为需要跟踪。这样就好理解后续 add 操作的实际意义了。）

###2.2.3 暂存已修改文件
现在我们修改下之前已跟踪过的文件 benchmarks.rb，然后再次运行 status 命令，会看到
这样的状态报告：
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
#
# new file: README
#
# Changes not staged for commit:
# (use "git add <file>..." to update what will be committed)
#
# modified: benchmarks.rb
#
文件 benchmarks.rb 出现在 “Changes not staged for commit” 这行下面，说明已跟
踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 git add 命令
（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪
新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状
###2.2.4忽略某些文件
一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。通
常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。我们可以创
建一个名为 .gitignore 的文件，列出要忽略的文件模式。来看一个实际的例子：

$ cat .gitignore
* .[oa]
// 上面的空格是我加上去的, 否则 .md 会解析 * 连起来的东西为特殊颜色
* ~

第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编
译过程中出现的，我们用不着跟踪它们的的版本。第二行告诉 Git 忽略所有以波浪符（~）
结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。此外，你可
能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。要养成一开始就设置好
.gitignore 文件的习惯，以免将来误提交这类无用的文件

文件 .gitignore 的格式规范如下：

所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。

可以使用标准的 glob 模式匹配。

匹配模式最后跟反斜杠（/）说明要忽略的是目录。

要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。
所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号（ * ）匹配零个或多个任
意字符；[abc] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 a，要么匹配一个
b，要么匹配一个 c）；问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两
个字符，表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹匹配所有 0 到 9 的数
字）。
我们再看一个 .gitignore 文件的例子：
# 此为注释
将被 Git 忽略
*.a # 忽略所有 .a 结尾的文件
!lib.a # 但 lib.a 除外
/TODO # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/ # 忽略 build/ 目录下的所有文件
doc/*.txt # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt


此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有
暂存起来的变化内容。
19
第2章 Git 基础 Scott Chacon Pro Git
若要看已经暂存起来的文件和上次提交时的快照之间的差异，可以用 git diff --cached 命
令。

（Git 1.6.1 及更高版本还允许使用 git diff --staged，效果是相同的，但更好记些。）


记住，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以
在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回
到这个状态，或者进行比较。

###2.2.7 跳过使用暂存区域
尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提
供了一个跳过使用暂存区域的方式，只要在提交的时候，给 git commit 加上 -a 选项，Git 就
会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤：(但是新文件就不行这么做...)


最后提交的时候，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存
区域的话，则必须要用强制删除选项 -f（译注：即 force 的首字母），以防误删除文件后丢
失修改的内容。
另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望
保留在当前工作目录中。换句话说，仅是从跟踪清单中删除。比如一些大型日志文件或者一
堆 .a 编译文件，不小心纳入仓库后，要移除跟踪但不删除文件，以便稍后在 .gitignore 文件
中补上，用 --cached 选项即可：
$ git rm --cached readme.txt

后面可以列出文件或者目录的名字，也可以使用 glob 模式。比方说：
$ git rm log/\*.log
注意到星号 * 之前的反斜杠 \，因为 Git 有它自己的文件模式扩展匹配方式，所以我们不
用 shell 来帮忙展开（译注：实际上不加反斜杠也可以运行，只不过按照 shell 扩展的话，
仅仅删除指定目录下的文件而不会递归匹配。上面的例子本来就指定了目录，所以效果等
同，但下面的例子就会用递归方式匹配，所以必须加反斜杠。）。此命令删除所有 log/ 目
录下扩展名为 .log 的文件。类似的比如：
$ git rm \*~
会递归删除当前目录及其子目录中所有 ~ 结尾的文件。

###3.3 分支管理
```js
  // git branch   
  // git branch -v  
  // git branch --merged  
  // git branch --no--merged  
  // git branch -d testing
  // error: The branch `testing` is not an ancestor for your current HEAD.
  // If you are sure you want to delete it, run `git branch -D testing`
```
###3.4 利用分支进行开发的工作流程

###3.6 分支的衍合
把一个分支的修改整合到另一个分支的办法有两种： merge和 rebase 衍合

最容易的整合分支方法是 merge 命令，他会把两个分支最新快照（c3 c4）以及二者的共同祖先c2进行三方合并，结果是产生一个新的提交对象 c5

其实还有另外一种选择： 可以把在 c3里产生的变化补丁在 c4的基础上重新打一遍=====rebase 这样就可以把在一个分支里提交的改变移到另一个分支里重放一遍
git checkout experiment
git rebase master
原理：回到两个分支最近的共同祖先，根据当前分支（也就是要进行沿河的分支 experiment）后续的历次提交对象（这里只有一个 c3）
，**生成一系列文件补丁**，然后以基底分支（这里是主干分支 master）最后一个提交对象 c4为新出发点，逐个应用之前准备好的补丁文件，最后会生成一个新的合并提交对象 c3`,从而改写 master 分支的直接下游

现在的 c3`对应的快照其实和普通的三方合并merge（上个例子中的 c5对应的快照内容一模一样了），虽然最后整合得到的结果没有任何区别，但是 rebase 能够产生一个更为简洁的提交历史，观察一个衍合过的分支的历史记录，看起来会更为清楚，仿佛所有修改都是在一根线上先后进行的，尽管实际上他们原本是同时并行发生的

rebase 是按照每行的修改次序重演一遍修改，而 merge 是把最终结果合在一起

git rebase --onto msater server client (选定新的基底分支 master，，，，，假设在接下来的一次 release 中，我们决定先把客户端的修改并到主线中，而暂缓并入服务端软件的修改（因为还需要进一步测试）,这时候我们可以把基于 server 分支而非 master 分支的改变（c8和 c9），跳过 server 直接放到 master 分之中重演一遍，，，应理解为在 c3时间点之后的 c8，c9修改放到主干重演，不包括 c3)


之后下一次 release 包含 server 分支的话， 可以 git rebase master server（不需要切换回 server 分支）
###3.6.3 衍合风险
一旦分支中的提交对象发布到公共仓库， 就千万不要对该分支进行衍合操作（所以说不要在 master 上线分支上直接 commit， push代码）     

在进行衍合的时候，实际上是抛弃了一些现存的提交对象而创造了一些类似但不同的新提交对象。。。如果把原来分支中的 commit release 出去，并且其他人更新下载后在其基础上开发工作，而稍后你又用 git rebase 抛弃这些提交对象，把新的重演后的 commit 发布出去的话，你的合作者就不得不重新合并他们的工作，当你再次从他们那里获取内容时，提交历史就会变得一团糟

#4 服务器上的git

架设一台 git 服务器并不难，第一步是选择与服务器通讯的协议，第一节介绍可用的协议以及各自优缺点。第二节介绍一些针对各个协议典型的设置以及如何在服务器上实施。第三节，如果你介意在他人服务器上保存你的代码，而且想免去自己架设和维护服务器的麻烦，可以试试我们介绍的几个仓库托管服务。

如果对架设自己的服务器没兴趣，可以跳到本章最后一节去看看如何申请一个带吗托管服务的账户然后继续下一章----分布式源码控制环境

远程仓库通常只是一个裸仓库，一个没有当前工作目录的仓库，只是一个合作媒介，不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 git 数据。裸仓库就是你工作目录中 .git 子目录内的内容

##4.1协议
git 使用四种主要协议来传输数据： 本地传输，SSH 协议，git 协议，http 协议。下面说说哪些情形应该使用或者避免使用这些协议。

除了 http 协议，其他所有协议都要求在服务器端安装并运行 git



git 使用的传输协议中最常见的就是 ssh 了，大多数环境已经支持通过 ssh 对服务器的访问--即便没有架设起来也很容易

ssh 也是唯一一个同时支持读写操作的网络协议，另外两个网络协议 http 和 git 通常都是只读的，所以虽然二两对大多数人都可用，但是执行写操作还是需要 ssh。ssh 同时也是一个验证授权的网络协议。因为普遍性，一般架设和使用都很容易。

通过 ssh 克隆一个仓库，可以向下面这样给出 ssh://的 URL

git clone: ssh://user@server:project.git    不指名某个协议git 会默认使用 ssh 不指明用户的话默认使用当前登录的用户连接服务器    

在本例中，我们使用了 Apache 设定中常用的 /var/www/htdocs 路径，不过你可以使用
任何静态 web 服务 — 把裸仓库放在它的目录里就行。 Git 的数据是以最基本的静态文件
的形式提供的（关于如何提供文件的详情见第9章 ）。

HTTP 协议的消极面在于，相对来说客户端效率更低。克隆或者下载仓库内容可能会花费
更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需
供应的能力 — 传输过程中没有服务端的动态计算 — 因而 HTTP 协议经常会被称为傻瓜
（dumb）协议。更多 HTTP 协议和其他协议效率上的差异见第9章 。


##4.3 生成 ssh 公钥
大多数git 服务器都会选择使用 ssh 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。首先先确认一下是否有一个公钥了。ssh 公钥默认存储在账户得住目录下的~/.ssh 目录
关键是看有没有用 sth 和 sth.pub来命名的一对文件。sth 通常是 id_rsa id_dsa... 有.pub 后缀的是公钥，另一个是密钥。假设没有这些文件或者没有.ssh目录,就可以用 ssh-keygen 来创建。该程序在 linux、Mac 上由 ssh 包提供。在 windows 上包含在 MSysGit 包里

cat ~/.ssh/id_rsa.pub   

##4.9 git 守护进程
对于提供公共的，非授权的只读访问，我们可以抛弃 HTTP 协议，改用 Git 自己的协
议，这主要是出于性能和速度的考虑。Git 协议远比 HTTP 协议高效，因而访问速度也快，
所以它能节省很多用户的时间。


每一个项目中所承担的责任   


在一家公司工作过的工作经历，经验，成绩描述





#5 分布式 git
##5.1分布式工作流程
###5.1.1集中式工作流
###5.1.2集成管理员工作流


1. 项目维护者可以推送数据到公共仓库 blessed repository。
2. 贡献者克隆此仓库，修订或编写新代码。
3. 贡献者推送数据到自己的公共仓库 developer public。
4. 贡献者给维护者发送邮件，请求拉取自己的最新修订。
5. 维护者在自己本地的 integration manger 仓库中，将贡献者的仓库加为远程仓库，
合并更新并做测试。
6. 维护者将合并后的更新推送到主仓库 blessed repository。

在 github 上使用的最多的就是这种流（开源项目）。人们可以复制（fork clone）某个项目到自己的列表中，成为自己的公共仓库，随后将自己的更新提交到这个仓库，所有人都可以看到每次你的更新。有点在于，你可以按照自己的节奏继续工作，而不必等待维护者处理你提交的更新；而维护者也可以按照自己的节奏，任何时候都可以处理接纳你的贡献。

###5.1.3司令官与副官工作流
这其实是上一种工作流的变体。一般超大型的项目才会用到这样的工作方式，像是拥有数
百协作开发者的 Linux 内核项目就是如此。各个集成管理员分别负责集成项目中的特定部
分，所以称为副官（lieutenant）。而所有这些集成管理员头上还有一位负责统筹的总集成
管理员，称为司令官（dictator）。司令官维护的仓库用于提供所有协作者拉取最新集成的
项目代码。整个流程看起来如图 5-3 所示：
1. 一般的开发者在自己的特性分支上工作，并不定期地根据主干分支（dictator 上的
master）衍合。
2. 副官（lieutenant）将普通开发者的特性分支合并到自己的 master 分支中。
3. 司令官（dictator）将所有副官的 master 分支并入自己的 master 分支。
4. 司令官（dictator）将集成后的 master 分支推送到共享仓库 blessed repository 中，
以便所有其他开发者以此为基础进行衍合。

这种工作流程并不常用，只有当项目极为庞杂，或者需要多级别管理时，才会体现出优
势。利用这种方式，项目总负责人（即司令官）可以把大量分散的集成工作委托给不同的小
组负责人分别处理，最后再统筹起来，如此各人的职责清晰明确，也不易出错（译注：此乃
分而治之）。
以上介绍的是常见的分布式系统可以应用的工作流程，当然不止于 Git。在实际的开发工
作中，你可能会遇到各种为了满足特定需求而有所变化的工作方式。我想现在你应该已经清
楚，接下来自己需要用哪种方式开展工作了。下节我还会再举些例子，看看各式工作流中的
每个角色具体应该如何操作。



###5.2.1 提交指南
开始分析特定用例之前，先来了解下如何撰写提交说明。一份好的提交指南可以帮助
协作者更轻松更有效地配合。Git 项目本身就提供了一份文档（Git 项目源代码目录中
Documentation/SubmittingPatches），列数了大量提示，从如何编撰提交说明到提交补丁，不
一而足。
首先，请不要在更新中提交多余的白字符（whitespace）。Git 有种检查此类问题的方
法，在提交之前，先运行 git diff --check，会把可能的多余白字符修正列出来。下面的示
例，我已经把终端中显示为红色的白字符用 X 替换掉



最后需要谨记的是提交说明的撰写。写得好可以让大家协作起来更轻松。一般来说，提交
说明最好限制在一行以内，50 个字符以下，简明扼要地描述更新内容，空开一行后，再展
开详细注解。Git 项目本身需要开发者撰写详尽注解，包括本次修订的因由，以及前后不同
实现之间的比较，我们也该借鉴这种做法。另外，提交说明应该用祈使现在式语态，比如，
不要说成 “I added tests for” 或 “Adding tests for” 而应该用 “Add tests for”。



#git 工具
##6.3 git stash 储藏 stashing
经常会发生：当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。但是你不想提交进行了一半的工作，否则以后你无法回到这个工作点，解决这个问题的办法就是 git stash。。。 stash 可以获取你工作目录的中间状态---也就是你修改过的被追踪的文件和暂存的变更---并将它保存到一个未完结变更的堆栈中，随时可以重新应用

这时候你可以方便的切换到其他分支上工作；你的变更都保存在栈上。。。。要查看现有的储藏，你可以使用 git stash list：


###6.4.1 改变最近一次提交

改变最近一次提交也许是最常见的重写历史的行为。对于你的最近一次提交，你经常想做
两件基本事情：改变提交说明，或者改变你刚刚通过增加，改变，删除而记录的快照。
如果你只想修改最近一次提交说明，这非常简单：
$ git commit --amend
这会把你带入文本编辑器，里面包含了你最近一次提交说明，供你修改。当你保存并退出
编辑器，这个编辑器会写入一个新的提交，里面包含了那个说明，并且让它成为你的新的最
近一次提交。
如果你完成提交后又想修改被提交的快照，增加或者修改其中的文件，可能因为你最初提
交时，忘了添加一个新建的文件，这个过程基本上一样。你通过修改文件然后对其运行git
add或对一个已被记录的文件运行git rm，随后的git commit --amend会获取你当前的暂存区并
将它作为新提交对应的快照。
#第7章 自定义 git
之前阐述了 git 基本的运作机制和使用方式，介绍了 git 提供的许多工具来帮助你简单且有效的使用他。
在本章，会介绍 git 的一些重要配置方法和钩子机制以满足自定义的要求。通过这些工具，工作配合起来天衣无缝

#7.1配置 git
git config --global user.name 'XXX XXX'
git config --global user.email XXX@example.com


git 使用一系列的配置文件来存储你定义的偏好，首先会查找/etc/gitconfig 全局配置文件，含有对系统上所有用户及他们所拥有的仓库都生效的配置值 如果传递 --system 选项给 git config，git 会读写该文件

接下来 git 会查找每个用户的~/.gitconfig 文件，你能传递 --global 让 git 读写该文件

最后 git 会查找由用户定义的各个库中 git 目录下的配置文件（.git/config），该文件中的值只对属主库有效。  

###7.1.1 客户端基本配置
git 能够识别的配置项： 客户端和服务器短

其中大部分基于你分人工作偏好，是客户端配置     
git config --help


##7.3 Git挂钩
和其他版本控制系统一样，当某些重要事件发生时，Git 以调用自定义脚本。有两组挂
钩：客户端和服务器端。客户端挂钩用于客户端的操作，如提交和合并。服务器端挂钩用于
Git 服务器端的操作，如接收被推送的提交。你可以随意地使用这些挂钩，下面会讲解其中
一些。
###7.3.1 安装一个挂钩
挂钩都被存储在 Git 目录下的hooks子目录中，即大部分项目中的.git/hooks。 Git 默认会
放置一些脚本样本在这个目录中，除了可以作为挂钩使用，这些样本本身是可以独立使用
的。所有的样本都是shell脚本，其中一些还包含了Perl的脚本，不过，任何正确命名的可执
行脚本都可以正常使用 — 可以用Ruby或Python，或其他。在Git 1.6版本之后，这些样本
名都是以.sample结尾，因此，你必须重新命名。在Git 1.6版本之前，这些样本名都是正确
的，但这些样本不是可执行文件。
把一个正确命名且可执行的文件放入 Git 目录下的hooks子目录中，可以激活该挂钩脚
本，因此，之后他一直会被 Git 调用。随后会讲解主要的挂钩脚本。
###7.3.2 客户端挂钩
有许多客户端挂钩，以下把他们分为：提交工作流挂钩、电子邮件工作流挂钩及其他客户
端挂钩。


提交工作流挂钩
有 4个挂钩被用来处理提交的过程。pre-commit挂钩在键入提交信息前运行，被用来检查
即将提交的快照，例如，检查是否有东西被遗漏，确认测试是否运行，以及检查代码。当从
该挂钩返回非零值时，Git 放弃此次提交，但可以用git commit --no-verify来忽略。该挂钩可
以被用来检查代码错误（运行类似lint的程序），检查尾部空白（默认挂钩是这么做的），
检查新方法（译注：程序的函数）的说明。

#第9张 git 内部原理

git 是一套内容寻址 content-addressable 文件系统，在此之上提供了一个 VCS 用户界面，早期的 git 的用户界面
要比现在复杂得多，这是因为它更侧重于
成为文件系统而不是一套更精致的 VCS 。最近几年改进了 UI 从而使它跟其他任何系统一
样清晰易用。即便如此，还是经常会有一些陈腔滥调提到早期 Git 的 UI 复杂又难学。
内容寻址文件系统层相当酷，在本章中我会先讲解这部分。随后你会学到传输机制和最终
要使用的各种库管理任务。

##9.1 底层命令Plumbing 高层命令 Porcelain

本书讲解了 checkout branch remote。。。约30个命令

然而由于 Git 一开始被
设计成供 VCS 使用的工具集而不是一整套用户友好的 VCS，它还包含了许多底层命令，
这些命令用于以 UNIX 风格使用或由脚本调用。这些命令一般被称为 “plumbing” 命令
（底层命令），其他的更友好的命令则被称为 “porcelain” 命令（高层命令）。
本书前八章主要专门讨论高层命令。本章将主要讨论底层命令以理解 Git 的内部工作机
制、演示 Git 如何及为何要以这种方式工作。这些命令主要不是用来从命令行手工使用的，
更多的是用来为其他工具和自定义脚本服务的。

当你在一个新目录或已有目录内执行 git init 时，Git 会创建一个 .git 目录，几乎所有 Git
存储和操作的内容都位于该目录下。如果你要备份或复制一个库，基本上将这一目录拷贝至
其他地方就可以了。本章基本上都讨论该目录下的内容。该目录结构如下：
$ ls
HEAD
branches/
config
description
hooks/
index
info/
objects/
refs/

该目录下有可能还有其他文件，但这是一个全新的 git init 生成的库，所以默认情况下这些
就是你能看到的结构。新版本的 Git 不再使用 branches 目录，description 文件仅供 GitWeb
程序使用，所以不用关心这些内容。config 文件包含了项目特有的配置选项，info 目录保
存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文
件。hooks 目录保存了第七章详细介绍了的客户端或服务端钩子脚本。

另外还有四个重要的文件或目录：HEAD 及 index 文件，objects 及 refs 目录。这些是 Git
的核心部分。objects 目录存储所有数据内容，refs 目录存储指向数据 (分支) 的提交对象的
指针，HEAD 文件指向当前分支，index 文件保存了暂存区域信息。马上你将详细了解 Git
是如何操纵这些内容的。

##9.2 Git 对象
Git 是一套内容寻址文件系统。很不错。不过这是什么意思呢？ 这种说法的意思是，Git
从核心上来看不过是简单地存储键值对（key-value）。它允许插入任意类型的内容，并会
返回一个键值，通过该键值可以在任何时候再取出该内容。可以通过底层命令 hash-object
来示范这点，传一些数据给该命令，它会将数据保存在 .git 目录并返回表示这些数据的键
值。首先初使化一个 Git 仓库并确认 objects 目录是空的：
$ mkdir test
$ cd test
$ git init
Initialized empty Git repository in /tmp/test/.git/
$ find .git/objects
.git/objects
.git/objects/info
.git/objects/pack
$ find .git/objects -type f
$
Git 初始化了 objects 目录，同时在该目录下创建了 pack 和 info 子目录，但是该目录下没
有其他常规文件。我们往这个 Git 数据库里存储一些文本：
$ echo 'test content' | git hash-object -w --stdin
d670460b4b4aece5915caf5c68d12f560a9fe3e4
226
Scott Chacon Pro Git 9.2节 Git 对象
参数 -w 指示 hash-object 命令存储 (数据) 对象，若不指定这个参数该命令仅仅返回键
值。--stdin 指定从标准输入设备 (stdin) 来读取内容，若不指定这个参数则需指定一个要存
储的文件的路径。该命令输出长度为 40 个字符的校验和。这是个 SHA-1 哈希值──其值
为要存储的数据加上你马上会了解到的一种头信息的校验和。现在可以查看到 Git 已经存储
了数据：
$ find .git/objects -type f
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
可以在 objects 目录下看到一个文件。这便是 Git 存储数据内容的方式──为每份内容生
成一个文件，取得该内容与头信息的 SHA-1 校验和，创建以该校验和前两个字符为名称的
子目录，并以 (校验和) 剩下 38 个字符为文件命名 (保存至子目录下)。
通过 cat-file 命令可以将数据内容取回。该命令是查看 Git 对象的瑞士军刀。传入 -p 参数
可以让该命令输出数据内容的类型：
$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
test content
可以往 Git 中添加更多内容并取回了。也可以直接添加文件。比方说可以对一个文件进行
简单的版本控制。首先，创建一个新文件，并把文件内容存储到数据库中：
$ echo 'version 1' > test.txt
$ git hash-object -w test.txt
83baae61804e65cc73a7201a7252750c76066a30
接着往该文件中写入一些新内容并再次保存：
$ echo 'version 2' > test.txt
$ git hash-object -w test.txt
1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
数据库中已经将文件的两个新版本连同一开始的内容保存下来了：
$ find .git/objects -type f
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4

再将文件恢复到第一个版本：
227
第9章 Git 内部原理 Scott Chacon Pro Git
$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 > test.txt
$ cat test.txt
version 1
或恢复到第二个版本：
$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a > test.txt
$ cat test.txt
version 2
需要记住的是几个版本的文件 SHA-1 值可能与实际的值不同，其次，存储的并不是文件
名而仅仅是文件内容。这种对象类型称为 blob 。通过传递 SHA-1 值给 cat-file -t 命令可以
让 Git 返回任何对象的类型：
$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
blob
###9.2.1 tree (树) 对象
接下去来看 tree 对象，tree 对象可以存储文件名，同时也允许存储一组文件。Git 以一
种类似 UNIX 文件系统但更简单的方式来存储内容。所有内容以 tree 或 blob 对象存储，
其中 tree 对象对应于 UNIX 中的目录，blob 对象则大致对应于 inodes 或文件内容。一个
单独的 tree 对象包含一条或多条 tree 记录，每一条记录含有一个指向 blob 或子 tree 对
象的 SHA-1 指针，并附有该对象的权限模式 (mode)、类型和文件名信息。以 simplegit
项目为例，最新的 tree 可能是这个样子：
$ git cat-file -p master^{tree}
100644 blob a906cb2a4a904a152e80877d4088654daad0c859 README
100644 blob 8f94139338f9404f26296befa88755fc2598c289 Rakefile
040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0 lib
master{tree}
表示 branch 分支上最新提交指向的 tree 对象。请注意 lib 子目录并非一个
blob 对象，而是一个指向别一个 tree 对象的指针：
$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b simplegit.rb


commit 对象有格式很简单：指明了该时间点项目快照的顶层树对象、作者/提交者信息
（从 Git 设置的 user.name 和 user.email中获得)以及当前时间戳、一个空行，以及提交注释
信息。
接着再写入另外两个 commit 对象，每一个都指定其之前的那个 commit 对象：
$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
cac0cab538b970a37ea1e769cbbde608743bc96d
$ echo 'third commit' | git commit-tree 3c4e9c -p cac0cab
1a410efbd13591db07496601ebc7a059dd55cfe9
每一个 commit 对象都指向了你创建的树对象快照。出乎意料的是，现在已经有了真实
的 Git 历史了，所以如果运行 git log 命令并指定最后那个 commit 对象的 SHA-1 便可以
查看历史：
$ git log --stat 1a410e
commit 1a410efbd13591db07496601ebc7a059dd55cfe9
Author: Scott Chacon <schacon@gmail.com>
Date: Fri May 22 18:15:24 2009 -0700


真棒。你刚刚通过使用低级操作而不是那些普通命令创建了一个 Git 历史。这基本上就是
运行　git add 和 git commit 命令时 Git 进行的工作　──保存修改了的文件的 blob，更新
索引，创建 tree 对象，最后创建 commit 对象，这些 commit 对象指向了顶层 tree 对象
以及先前的 commit 对象。这三类 Git 对象 ── blob，tree 以及 tree ── 都各自以文件
的方式保存在 .git/objects 目录下。以下所列是目前为止样例中的所有对象，每个对象后面
的注释里标明了它们保存的内容：
$ find .git/objects -type f
.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1


###9.3.2 Tags
你刚刚已经重温过了 Git 的三个主要对象类型，现在这是第四种。Tag 对象非常像一个
commit 对象——包含一个标签，一组数据，一个消息和一个指针。最主要的区别就是 Tag
对象指向一个 commit 而不是一个 tree。它就像是一个分支引用，但是不会变化——永远
指向同一个 commit，仅仅是提供一个更加友好的名字。
正如我们在第二章所讨论的，Tag 有两种类型：annotated 和 lightweight 。你可以类似
下面这样的命令建立一个 lightweight tag：
$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d
这就是 lightweight tag 的全部 —— 一个永远不会发生变化的分支。 annotated tag 要
更复杂一点。如果你创建一个 annotated tag，Git 会创建一个 tag 对象，然后写入一个指
向指向它而不是直接指向 commit 的 reference。你可以这样创建一个 annotated tag（-a
参数表明这是一个 annotated tag）：
$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 -m 'test tag'
